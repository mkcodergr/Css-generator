/*jslint node: true */
'use strict';
(function($, window, documents, exports) {
	var map = Array.prototype.map;
	var demoOutput;
	var x = '',
		y = '',
		z = '',
		final_transformation = 'none',
		scalex = '',
		scaley = '',
		translatex = '',
		translatey = '',
		translatez = '',
		skewY = '',
		skewX = '';
	var hor = '',
		ver = '',
		blur = '',
		spread = '',
		inset = '',
		red = "0",
		green = "0",
		blue = "0",
		color = 'rgb(250,48,90)',
		bshadow = 'none',
		transparency = 1; //box-shadow
	var tl = '',
		tr = '',
		bl = '',
		br = '',
		rad = 0; //border-radius
	//Text shadow properies
	var text_shadow = "none",
		text_shadow_x_axis = "",
		text_shadow_y_axis = "",
		text_shadow_blur = "";
	//Text shadow color
	//Note:We could use the color from the box-shadow but instead we choose to seperate box-shadow color from text-shadow color
	var text_shadow_r = 0,
		text_shadow_g = 0,
		text_shadow_b = 0,
		text_shadow_opacity = 0,
		text_shadow_color = "";
	var transform_fav = [],
		radius_fav = [],
		box_fav = [],
		text_fav = [];
	var transform_col = 0,
		box_col = 0,
		radius_col = 0,
		text_col = 0; //columns in each table
	var line = [false, false, false, false]; //this array is used to create a new row in each favourite table after adding 3 cells in each row
	//Select which generators you want to see on the page
	var visibleGenerators = [];
	var selectEnabledGenerators = function(generators) {
		//List of generators to show
		var list = generators;
		var allGenerators = $(".generatorContainer");
		var outputs = $("#export .list-group-item");
		//Hide all generators
		allGenerators.hide();
		//Hide all generator outputs
		outputs.hide();
		//http://stackoverflow.com/questions/41352896/rewrite-for-loop-as-filter-javascript
		//Maybe rewrite it to create a dom string and use it once
		var generatorString = ".generatorContainer[data-generator=" + (list.join("],.generatorContainer[data-generator=")) + "]";
		var outputString = "outputs[" + (list.join("],outputs[")) + "]";
		$(generatorString).show();
		list.forEach(function(item) {
			$(outputs[item]).show();
		});
	};
	var showGeneratorList = function() {
		var list;
		var listItem = (text,index,identation) =>{
			return "<div class='list-group-item generatorItem' data-index='"+index+"'>"+text+"</div>"+ (!identation?"\n":"\n\t\t\t\t");
		};
		var markup = "<div class ='panel panel-primary' style='margin-top:10px'>\n\t";
		markup += "<div class='panel-heading'>Choose which generators to show</div>\n\t"
		markup += "<div class='panel-body'>\n\t\t";
		markup += "<div class='list-group'>\n\t\t\t";
		["Css Transform","Css Box Shadow","Css Border Radius","Css Text Shadow"].forEach((item,index)=>{
			markup+=listItem(item,index,index != 3);
		});
		markup += "</div>";
		bootbox.alert({
			message: markup,
			callback: function() {
				//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
				list = map.call($(".generatorItemSelected"), function(i) {
					return $(i).data("index");
				});
				if (list)
					selectEnabledGenerators(list);
			}
		});
		//Fix that to avoid collisions with toggle()
		visibleGenerators = $(".generatorContainer:visible");
		//From each visible generatorContainer extract its data-generator value
		var visibleGeneratorsIndex = map.call(visibleGenerators, function(i) {
			return $(i).data("generator");
		});
		//If there are 4 visible generatorContainer it means that all generators are visible
		//so mark them as both active and selected
		if (len(visibleGeneratorsIndex) == 4) {
			$(".generatorItem").addClass("active generatorItemSelected");
		} else {
			var generatorsToSelect = map.call(visibleGeneratorsIndex, function(i) {
				return ".generatorItem[data-index=" + i + "]";
			}).join(",");
			//Each generator that is selected also has to be marked as selected
			$(generatorsToSelect).addClass("active generatorItemSelected");
		}
	};
	var updateText = function(selector, text) {
		$(selector).text(text);
	};
	var Color = function(red, green, blue, alpha) {
		this.r = red;
		this.g = green;
		this.b = blue;
		this.a = alpha;
		//If no alpa value was provided treat this color as an rgb color by setting alpha value to 1
		if (arguments[3] == undefined)
			this.a = 1;
		this.getColor = function() {
			if (this.a == 1)
				return " rgb(" + this.r + "," + this.g + "," + this.b + ")";
			else
				return " rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
			//return this.a==1?" rgb(" + this.r + "," + this.g + "," + this.b + ")":" rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
		}
		this.toString = this.getColor;
	};
	var log = (obj) => console.log(obj);
	var len = (obj) => obj.length;
	function saveCode(type) {
		var prefix = (property, value) => {
			var css = "";
			css += "-webkit-" + property + ":" + value + ";\n";
			css += "-moz-" + property + "   :" + value + ";\n";
			css += "-ms-" + property + "    :" + value + ";\n";
			css += property + "             :" + value + ";\n";
			return css;
		};
		var file, blob;
		switch (type) {
			case "f":
				file = "/***\n";
				var favourite_items = "";
				transform_fav.forEach(value=>{
					favourite_items += prefix("transform", value);
				});
				box_fav.forEach(value=>{
					favourite_items += prefix("box-shadow", value);
				});
				radius_fav.forEach(value=>{
					favourite_items += "border-radius:" + value + ";\n";
				});
				//Maybe for text shadow and border radius we can use join()
				//to join the array elements without using forEach
				// if(text_fav.length > 1)
				//favourite_items += (text-shadow+ text_fav.join(";text-shadow:"))+";"
				text_fav.forEach(value=>{
					favourite_items += "text-shadow:" + value + ";\n";
				});
				file += favourite_items;
				file += "***/\n";
				break;
			default:
				if (bshadow == "none" && rad == 0 && final_transformation == "none" && text_shadow == "none")
					return;
				file = "div{\n\t";
				if (final_transformation != "none" && final_transformation)
					file += prefix("transform", final_transformation) + "\t";
				if (bshadow && bshadow != "none")
					file += prefix("box-shadow", bshadow) + "\t";
				if (rad != 0)
					file += "border-radius:" + rad + ";\n\t";
				if (text_shadow != "none")
					file += "text-shadow:" + text_shadow + ";\n";
				file += "}";
				break;
		} //switch
		blob = new Blob([file], {
			type: "text/plain;charset=utf-8"
		});
		saveAs(blob, type == 'f' ? 'favourites.css' : 'transformations.css');
	}
	function fav(type) {
		switch (type) {
			case "text-shadow":
				if (text_shadow && text_shadow != "none" && text_fav.indexOf(text_shadow) == -1) {
					text_fav.push(text_shadow);
					if (!line[3]) {
						$("#table_text tbody").append("<tr>");
						line[3] = true;
					}
					if (text_col % 3 == 0) {
						$("#table_text").append("</tr><tr>");
					}
					$("#table_text tbody tr:last").append("<td class='marked text_marked'>" + text_shadow + "</td>");
					text_col++;
					updateText("#text_total", "(" + len(text_fav) + ")")
				}
			case "radius":
				if (rad !== 0 && radius_fav.indexOf(rad) == -1) {
					radius_fav.push(rad);
					if (!line[2]) {
						$("#table_rad tbody").append("<tr>");
						line[2] = true;
					}
					if (radius_col == 3) {
						radius_col = 0;
						$("#table_rad").append("</tr><tr>");
					}
					$("#table_rad tbody tr:last").append("<td class='marked rad_marked'>" + rad + "</td>");
					radius_col++;
					updateText("#radius_total", "(" + len(radius_fav) + ")");
				}
				break;
			case "transform":
				if (final_transformation && transform_fav.indexOf(final_transformation) == -1 && final_transformation !== "rotate(0)" && final_transformation !== "none") {
					//mind the gap after rotate(0)
					transform_fav.push(final_transformation);
					if (!line[0]) {
						$("#table_tran tbody").append("<tr>");
						line[0] = true;
					}
					$("#table_tran tbody tr:last").append("<td class='transform_marked marked'>" + final_transformation + "</td>");
					transform_col++;
					if (transform_col % 3 == 0) {
						$("#table_tran").append("</tr><tr>");
					}
					updateText("#totaltran", "(" + len(transform_fav) + ")");
				}
				break;
			default:
				if (box_fav.indexOf(bshadow) == -1 && bshadow != "none") {
					box_fav.push(bshadow);
					if (!line[1]) {
						$("#table_box tbody").append("<tr>");
						line[1] = true;
					}
					$("#table_box tbody tr:last").append("<td class='box_marked marked'>" + bshadow + "</td>");
					box_col++;
					if (box_col % 3 == 0) {
						$("#table_box").append("</tr><tr>");
					}
					updateText("#box_total", "(" + len(box_fav) + ")");
				} //if
				break;
		} //switch
	} //fav
	function removefav() {
		bootbox.confirm("Are you sure you want to delete your favourites?", function(answer) {
			//bootbox.confirm() requires a callback function as the second parameter
			if (answer) {
				//line[0] = line[1] = line[2] = line[3] = false;
				line = line.map(function() {
					return false;
				});
				//empty all the lists
				box_fav.length = radius_fav.length = transform_fav.length = text_fav.length = 0;
				updateText("#box_total,#totaltran,#radius_total,#text_total", "(0)");
				$(".marked").remove();
			}
		});
	}
	var updateMechanism = {
		//This object will update all the relevant variables
		val: function(o) {
			return $(o).val();
		},
		float: function(value) {
			return parseFloat(this.val(value));
		},
		int: function(value) {
			return parseInt(this.val(value));
		},
		updateTransformationValues: function() {
			x = this.int("#rotatexd");
			y = this.int("#rotatey");
			z = this.int("#rotatez");
			scalex = this.float("#scalex");
			scaley = this.float("#scaley");
			translatex = this.int("#tranx");
			translatey = this.int("#trany");
			translatez = this.int("#tranz");
			skewY = this.int("#skewy");
			skewX = this.int("#skewx");
			return updateMechanism;
		},
		updateBoxShadowValues: function() {
			hor = this.val("#hor_axis");
			ver = this.val("#ver_axis");
			blur = this.val('#blur');
			spread = this.val("#spread");
			transparency = this.float("#trans");
			inset = this.int("#in");
			/*colors*/
			red = this.int("#red");
			green = this.int("#green");
			blue = this.int("#blue");
			return updateMechanism;
		},
		updateTextShadowValues: function() {
			text_shadow_x_axis = this.int("#text_shadow_x");
			text_shadow_y_axis = this.int("#text_shadow_y");
			text_shadow_blur = this.float("#text_shadow_blur");
			text_shadow_r = this.int("#text_shadow_red");
			text_shadow_g = this.int("#text_shadow_green");
			text_shadow_b = this.int("#text_shadow_blue");
			text_shadow_opacity = this.float("#text_shadow_opacity");
			return updateMechanism;
		},
		updateBorderRadiusValues: function() {
			tl = this.val("#tl");
			tr = this.val("#tr");
			bl = this.val("#bl");
			br = this.val("#br");
			return updateMechanism;
		},
		updateAllValues: function() {
			updateMechanism.updateTransformationValues()
				.updateBoxShadowValues()
				.updateTextShadowValues()
				.updateBorderRadiusValues();
		}
	};
	var update = updateMechanism.updateAllValues;
	var createTransformation = function() {
		var final_transformation = "";
		if (x)
			final_transformation += "rotateX(" + x + "deg)";
		if (y)
			final_transformation += " rotateY(" + y + "deg)";
		if (z)
			final_transformation += " rotateZ(" + z + "deg)";
		if (scalex !== 1 || scaley !== 1)
			final_transformation += " scale(" + scalex + "," + scaley + ")";
		if (translatex !== 0 || translatey !== 0 || translatez !== 0) {
			if (translatex !== 0 && translatey == 0 && translatez == 0)
				final_transformation += " translateX(" + translatex + "px)";
			else if (translatey !== 0 && translatex == 0 && translatez == 0)
				final_transformation += " translateY(" + translatey + "px)";
			else if (translatez !== 0 && translatex == 0 && translatey == 0)
				final_transformation += " translateZ(" + translatez + "px)";
			else if (translatex == 0)
				final_transformation += " translateY(" + translatey + "px) translateZ(" + translatez + "px)";
			else if (translatez == 0)
				final_transformation += " translateX(" + translatex + "px) translateY(" + translatey + "px)";
			else if (translatey == 0)
				final_transformation += " translateX(" + translatex + "px) translateZ(" + translatez + "px)";
			else
				final_transformation += " translateX(" + translatex + "px) translateY(" + translatey + "px) translateZ(" + translatez + "px)";
		}
		//if scalex != 1 || scaley != 1 
		//If the skew's sliders have been changed e.g, moved from 0 to 1 or from 0 to 100 add skew property
		if (skewX || skewY)
			final_transformation += " skew(" + skewX + "deg," + skewY + "deg)";
		return final_transformation;
	};
	var createTextShadow = function() {
		var shadow = "none";
		//fixes #issue18
		if (text_shadow_x_axis != 0 || text_shadow_y_axis != 0 != text_shadow_blur != 0) {
			/*
			 ** Always add y axis value even if it is zero 
			 */
			shadow = text_shadow_x_axis + "px " + text_shadow_y_axis + "px "+text_shadow_blur + "px ";
			text_shadow_color = new Color(text_shadow_r, text_shadow_g, text_shadow_b, text_shadow_opacity).toString();
			shadow += text_shadow_color;
		}
		return shadow;
	};
	var createBoxShadow = function() {
		var boxShadow;
		//No need to check for color because whatever the color is if the basic sliders are set to 0
		//no shadow will be shown
		if (hor + ver + blur + spread == 0) {
			return "none";
		}
		boxShadow = hor + "px " + ver + "px " + blur + "px " + spread + "px";
		color = new Color(red, green, blue, transparency).toString();
		if (inset) boxShadow = "inset " + boxShadow;
		if (boxShadow != 'none')
			boxShadow += color;
		return boxShadow;
	};
	var createRadius = function() {
		var radius;
		if (tl + tr + bl + br == 0)
			radius = 0;
		else
			radius = tl + "px " + tr + "px " + br + "px " + bl + "px";
		return radius;
	};
	$(function() {
		var decomposer = {
			decomposeColor: function(color) {
				//Extract color values from an rgb colors
				//E.g. rgb(12,44,190)gives [12,44,190]
				var colors = color.split("rgb")[1].split("(")[1].split(",");
				var max = colors.length - 1;
				colors[max] = colors[max].split(")")[0];
				if (len(colors) == 3)
					colors.push(1);
				return colors;
			},
			removeColor: function(code) {
				return code.split("rgb")[0];
			},
			//Do not map var.If true is passed the result return is not mapped
			decomposeTextShadow: function(code, doNotMap) {
				code = decomposer.removeColor(code);
				var shadowValues = code.trim().split("px");
				return doNotMap ? shadowValues : shadowValues.map(Number);
			},
			//Since we do the same things as we would in text shadow there is no need to
			//rewrite code
			decomposeBoxShadow: function(code) {
				var inset = code.indexOf("inset") != -1 ? 1 : 0;
				var array = this.decomposeTextShadow(code, true);
				//remove the empty element
				array.pop();
				//Check if there is no spread or blur before pushing inset value
				while (array.length < 4)
					array.push(0);
				if (inset) {
					array[0] = array[0].split("inset")[1];
				}
				//Only after eerything is finished add the inset slider
				array.push(inset);
				return array.map(Number);
			},
			decomposeRadius: function(code) {
				var radiusValues = code.split("px");
				//You get an array with one empty value which is ""
				//so pop it
				radiusValues.pop();
				//Re arrange the array
				//Values are as following :top left , top right,bottom right, bottom left
				//but the sliders are top left , top right,bottom left, bottom right
				//so swap the last 2 elements 
				var temp = radiusValues[3];
				radiusValues[3] = radiusValues[2];
				radiusValues[2] = temp;
				return radiusValues.map(Number);
			},
			decomposeTransformation: function(code) {
				var getAllIndexes = function(arr, val) {
					var indexes = [],
						i = -1;
					//To understand the second parameter of indexOf function
					//have a look at this : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
					while ((i = arr.indexOf(val, i + 1)) != -1) {
						indexes.push(i);
					}
					return indexes;
				};
				var extractRotationValues = function(string) {
					var values = {
						x: 0,
						y: 0,
						z: 0
					};
					string.replace(/\brotate([XYZ])\s*\(\s*([+-]?[\d.]+)\s*deg\s*\)/g, function(_, axis, value) {
						values[axis.toLowerCase()] = parseFloat(value);
					});
					return [values.x, values.y, values.z];
				};
				var extractScaleValues = function(string) {
					return string.indexOf("scale(") != -1 ?
						string.split("scale(")[1].split(")")[0].split(",").map(Number) : [0, 0];
				};
				var extractSkewValues = function(string) {
					if (string.indexOf("skew(") == -1)
						return [0, 0];
					var valueX = string.split("skew(")[1].split("deg,")[0];
					var valueY = string.split("skew(")[1].split("deg,")[1].split("deg")[0];
					return [valueX, valueY].map(Number);
				};
				var extractTranslateValues = function(string) {
					var values = {
						x: 0,
						y: 0,
						z: 0
					};
					string.replace(/\btranslate([XYZ])\s*\(\s*([+-]?[\d.]+)\s*px\s*\)/g, function(_, axis, value) {
						values[axis.toLowerCase()] = parseFloat(value);
					});
					return [values.x, values.y, values.z];
				};
				var rotateValues = extractRotationValues(code);
				var scaleValues = extractScaleValues(code);
				var translateValues = extractTranslateValues(code);
				var skewValues = extractSkewValues(code);
				//Add all values of each array using spread operator
				//See this link for reference
				//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
				return [...rotateValues, ...scaleValues, ...translateValues, ...skewValues];
			}
		};
		var sliders = {
			textColors: $(".text_color"),
			boxColors: $(".bcolor"),
			boxSliders: $(".box_shadow:not(.bcolor)"),
			textSliders: $(".text_shadow_slider"),
			radiusSliders: $(".radius"),
			transformationSliders: $(".transform_slider"),
			textShadowSliders: function() {
				return sliders.textSliders;
			},
			textShadowColors: function() {
				return sliders.textColors;
			},
			boxShadowSliders: function() {
				return sliders.boxSliders;
			},
			boxShadowColors: function() {
				return sliders.boxColors;
			},
			borderRadiusSliders: function() {
				return this.radiusSliders;
			},
			transformSliders: function() {
				return this.transformationSliders;
			}
		};
		$("#generatorSelector").on("click", showGeneratorList);
		$("#removeFavouritesBtn").on("click", removefav);
		$("#downloadFavourites").on("click", function() {
			saveCode('f');
		});
		$("#downloadCode").on("click", saveCode);
		$("body").on("click", ".list-group-item.generatorItem", function() {
			$(this).toggleClass("active generatorItemSelected");
		}).on('click', '.modal-backdrop', function(event) {
			bootbox.hideAll();
		});
		$("#code_output .list-group").on("click", ".list-group-item", function() {
			$(this).toggleClass("active");
		});
		$("#addToFavouritesBtn").on("click", function() {
			//Returns an HTMLCollection
			//HTMLCollection does not have a forEach method
			var list = $("#code_output .list-group .list-group-item.active");
			//Convert "list" into an array by slicing it
			[...list].forEach(fn => {
				eval($(fn).data("function"));
			});
		});
		demoOutput = $("#totransform");
		$("#controllers h1").click(function() {
			$(this).next('.slider_container').toggle(800);
		});
		//var rotate = (axis,deg)=> "rotate"+axis+"("+deg+"deg)";
		$(".ultra_app").on("input change touchmove", function() {
			update();
			final_transformation = createTransformation();
			bshadow = createBoxShadow();
			rad = createRadius();
			text_shadow = createTextShadow();
			demoOutput.css({
				"transform": final_transformation,
				"box-shadow": bshadow,
				"border-radius": rad
			});
			$("#text_shadow_demo").css("text-shadow", text_shadow);
			updateText('.transform', final_transformation == '' ? 'none' : final_transformation);
			updateText('.box', bshadow);
			updateText('.borderRadius', rad);
			updateText(".text_shadow_code_output", text_shadow);
		});
		$("#restart").click(function() {
			final_transformation = bshadow = text_shadow = "none";
			rad = 0;
			$('.ultra_app:not(#trans,#text_shadow_opacity,.scale)').val(0);
			// fixes #24
			$('.scale,#trans,#text_shadow_opacity').val(1);
			demoOutput.css({
				"transform": "none",
				"box-shadow": "none",
				"border-radius": "0"
			});
			$("#text_shadow_demo").css("text-shadow", "none");
			updateText('.transform,.box,.text_shadow_code_output,.borderRadius', "none");
		});
		$("#table_tran,#table_text,#table_box,#table_rad").on("click", "td", function(e) {
			var processCode = (code, table) => {
				var sliderValues = [];
				var curSliders = null;
				var colorSliders = null;
				var colorValues = null;
				//This is the output div
				var outputTextSelector = null;
				//The property that will be updated
				var propertyToUpdate = null;
				//Set the sliders depending on the table clicked
				if (table == "#table_tran") {
					propertyToUpdate = "transform";
					outputTextSelector = ".transform";
					final_transformation = code;
					curSliders = sliders.sliders.transformSliders();
					final_transformation = code;
					sliderValues = decomposer.decomposeTransformation(final_transformation);
				} else if (table == "#table_text") {
					outputTextSelector = ".text_shadow_code_output";
					text_shadow = code;
					//Here we leave the `propertyToUpdate` set to `null`
					$("#text_shadow_demo").css("text-shadow", text_shadow);
					curSliders = sliders.textShadowSliders();
					colorSliders = sliders.textShadowColors();
					sliderValues = decomposer.decomposeTextShadow(text_shadow);
					colorValues = decomposer.decomposeColor(text_shadow);
				} else if (table == "#table_box") {
					bshadow = code;
					propertyToUpdate = "box-shadow";
					outputTextSelector = ".box";
					curSliders = sliders.boxShadowSliders();
					colorSliders = sliders.boxShadowColors();
					sliderValues = decomposer.decomposeBoxShadow(bshadow);
					colorValues = decomposer.decomposeColor(bshadow);
				} else {
					rad = code;
					propertyToUpdate = "border-radius";
					outputTextSelector = ".borderRadius";
					curSliders = sliders.borderRadiusSliders();
					sliderValues = decomposer.decomposeRadius(rad);
				}
				//If we don't want to apply text shadow
				if (propertyToUpdate)
					demoOutput.css(propertyToUpdate, code);
				$(outputTextSelector).text(code);
				[...curSliders].forEach(slider =>{
					$(slider).val(sliderValues.shift());
				});
				if (colorSliders)
					[...colorSliders].forEach(colorSlider =>$(colorSlider).val(colorValues.shift()));
			};
			var code = $(this).text();
			//Get the parent table id of the clicked td
			var parentTable = "#" +$(this).closest("table").attr("id");
			processCode(code, parentTable);
		});
	});
}(window.jQuery, window, document));
